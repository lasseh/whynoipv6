// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: campaign.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const CrawlCampaignDomain = `-- name: CrawlCampaignDomain :many
SELECT id, campaign_id, site, base_domain, www_domain, nameserver, mx_record, v6_only, asn_id, country_id, disabled, ts_base_domain, ts_www_domain, ts_nameserver, ts_mx_record, ts_v6_only, ts_check, ts_updated
FROM campaign_domain
ORDER BY id
LIMIT $1 OFFSET $2
`

type CrawlCampaignDomainParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) CrawlCampaignDomain(ctx context.Context, arg CrawlCampaignDomainParams) ([]CampaignDomain, error) {
	rows, err := q.db.Query(ctx, CrawlCampaignDomain, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CampaignDomain{}
	for rows.Next() {
		var i CampaignDomain
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Site,
			&i.BaseDomain,
			&i.WwwDomain,
			&i.Nameserver,
			&i.MxRecord,
			&i.V6Only,
			&i.AsnID,
			&i.CountryID,
			&i.Disabled,
			&i.TsBaseDomain,
			&i.TsWwwDomain,
			&i.TsNameserver,
			&i.TsMxRecord,
			&i.TsV6Only,
			&i.TsCheck,
			&i.TsUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const CreateCampaign = `-- name: CreateCampaign :one
INSERT INTO campaign(name, description)
VALUES ($1, $2)
RETURNING id, created_at, uuid, name, description, disabled
`

type CreateCampaignParams struct {
	Name        string
	Description string
}

func (q *Queries) CreateCampaign(ctx context.Context, arg CreateCampaignParams) (Campaign, error) {
	row := q.db.QueryRow(ctx, CreateCampaign, arg.Name, arg.Description)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.Disabled,
	)
	return i, err
}

const CreateOrUpdateCampaign = `-- name: CreateOrUpdateCampaign :one
INSERT INTO campaign(uuid, name, description)
VALUES ($1, $2, $3)
ON CONFLICT (uuid) DO UPDATE
    SET name        = EXCLUDED.name,
        description = EXCLUDED.description
RETURNING id, created_at, uuid, name, description, disabled
`

type CreateOrUpdateCampaignParams struct {
	Uuid        uuid.UUID
	Name        string
	Description string
}

func (q *Queries) CreateOrUpdateCampaign(ctx context.Context, arg CreateOrUpdateCampaignParams) (Campaign, error) {
	row := q.db.QueryRow(ctx, CreateOrUpdateCampaign, arg.Uuid, arg.Name, arg.Description)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.Disabled,
	)
	return i, err
}

const DeleteCampaignDomain = `-- name: DeleteCampaignDomain :exec
DELETE
FROM campaign_domain
WHERE campaign_id = $1
  AND site = $2
`

type DeleteCampaignDomainParams struct {
	CampaignID uuid.UUID
	Site       string
}

func (q *Queries) DeleteCampaignDomain(ctx context.Context, arg DeleteCampaignDomainParams) error {
	_, err := q.db.Exec(ctx, DeleteCampaignDomain, arg.CampaignID, arg.Site)
	return err
}

const DisableCampaignDomain = `-- name: DisableCampaignDomain :exec
UPDATE
    campaign_domain
SET disabled = TRUE
WHERE site = $1
`

func (q *Queries) DisableCampaignDomain(ctx context.Context, site string) error {
	_, err := q.db.Exec(ctx, DisableCampaignDomain, site)
	return err
}

const GetCampaignByUUID = `-- name: GetCampaignByUUID :one
SELECT campaign.id, campaign.created_at, campaign.uuid, campaign.name, campaign.description, campaign.disabled,
       COUNT(campaign_domain.id) AS domain_count,
       COUNT(
               CASE
                   WHEN campaign_domain.base_domain = 'supported' AND
                        campaign_domain.www_domain = 'supported' AND
                        campaign_domain.nameserver = 'supported'
                       THEN 1
                   ELSE NULL
                   END
           )                     AS v6_ready_count
FROM campaign
         LEFT JOIN campaign_domain ON campaign.uuid = campaign_domain.campaign_id
WHERE campaign.uuid = $1
GROUP BY campaign.id
LIMIT 1
`

type GetCampaignByUUIDRow struct {
	ID           int64
	CreatedAt    time.Time
	Uuid         uuid.UUID
	Name         string
	Description  string
	Disabled     bool
	DomainCount  int64
	V6ReadyCount int64
}

func (q *Queries) GetCampaignByUUID(ctx context.Context, argUuid uuid.UUID) (GetCampaignByUUIDRow, error) {
	row := q.db.QueryRow(ctx, GetCampaignByUUID, argUuid)
	var i GetCampaignByUUIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.Disabled,
		&i.DomainCount,
		&i.V6ReadyCount,
	)
	return i, err
}

const GetCampaignDomainsByName = `-- name: GetCampaignDomainsByName :many
SELECT id, campaign_id, site, base_domain, www_domain, nameserver, mx_record, v6_only, asn_id, country_id, disabled, ts_base_domain, ts_www_domain, ts_nameserver, ts_mx_record, ts_v6_only, ts_check, ts_updated
FROM campaign_domain
WHERE site LIKE '%' || $1 || '%'
LIMIT $2 OFFSET $3
`

type GetCampaignDomainsByNameParams struct {
	Column1 sql.NullString
	Limit   int64
	Offset  int64
}

// Used for searching campaign domains by site name.
func (q *Queries) GetCampaignDomainsByName(ctx context.Context, arg GetCampaignDomainsByNameParams) ([]CampaignDomain, error) {
	rows, err := q.db.Query(ctx, GetCampaignDomainsByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CampaignDomain{}
	for rows.Next() {
		var i CampaignDomain
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Site,
			&i.BaseDomain,
			&i.WwwDomain,
			&i.Nameserver,
			&i.MxRecord,
			&i.V6Only,
			&i.AsnID,
			&i.CountryID,
			&i.Disabled,
			&i.TsBaseDomain,
			&i.TsWwwDomain,
			&i.TsNameserver,
			&i.TsMxRecord,
			&i.TsV6Only,
			&i.TsCheck,
			&i.TsUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const InsertCampaignDomain = `-- name: InsertCampaignDomain :exec
INSERT INTO campaign_domain(campaign_id, site)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type InsertCampaignDomainParams struct {
	CampaignID uuid.UUID
	Site       string
}

// The ON CONFLICT DO NOTHING clause prevents errors in case a record with the same campaign_id and site already exists.
func (q *Queries) InsertCampaignDomain(ctx context.Context, arg InsertCampaignDomainParams) error {
	_, err := q.db.Exec(ctx, InsertCampaignDomain, arg.CampaignID, arg.Site)
	return err
}

const ListCampaign = `-- name: ListCampaign :many
SELECT campaign.id, campaign.created_at, campaign.uuid, campaign.name, campaign.description, campaign.disabled,
       COUNT(campaign_domain.id) AS domain_count,
       COUNT(
               CASE
                   WHEN campaign_domain.base_domain = 'supported' AND
                        campaign_domain.www_domain = 'supported' AND
                        campaign_domain.nameserver = 'supported'
                       THEN 1
                   ELSE NULL
                   END
           )                     AS v6_ready_count
FROM campaign
         LEFT JOIN campaign_domain ON campaign.uuid = campaign_domain.campaign_id AND campaign.disabled = FALSE
GROUP BY campaign.id
ORDER BY campaign.id
`

type ListCampaignRow struct {
	ID           int64
	CreatedAt    time.Time
	Uuid         uuid.UUID
	Name         string
	Description  string
	Disabled     bool
	DomainCount  int64
	V6ReadyCount int64
}

// Description: Retrieves a list of campaigns along with their associated domain count.
func (q *Queries) ListCampaign(ctx context.Context) ([]ListCampaignRow, error) {
	rows, err := q.db.Query(ctx, ListCampaign)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCampaignRow{}
	for rows.Next() {
		var i ListCampaignRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.Disabled,
			&i.DomainCount,
			&i.V6ReadyCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCampaignDomain = `-- name: ListCampaignDomain :many
SELECT campaign_domain.id, campaign_domain.campaign_id, campaign_domain.site, campaign_domain.base_domain, campaign_domain.www_domain, campaign_domain.nameserver, campaign_domain.mx_record, campaign_domain.v6_only, campaign_domain.asn_id, campaign_domain.country_id, campaign_domain.disabled, campaign_domain.ts_base_domain, campaign_domain.ts_www_domain, campaign_domain.ts_nameserver, campaign_domain.ts_mx_record, campaign_domain.ts_v6_only, campaign_domain.ts_check, campaign_domain.ts_updated,
       asn.name as asname,
       country.country_name
FROM campaign_domain
         LEFT JOIN asn ON campaign_domain.asn_id = asn.id
         LEFT JOIN country ON campaign_domain.country_id = country.id
WHERE campaign_domain.campaign_id = $1
ORDER BY campaign_domain.id
LIMIT $2 OFFSET $3
`

type ListCampaignDomainParams struct {
	CampaignID uuid.UUID
	Limit      int64
	Offset     int64
}

type ListCampaignDomainRow struct {
	ID           int64
	CampaignID   uuid.UUID
	Site         string
	BaseDomain   string
	WwwDomain    string
	Nameserver   string
	MxRecord     string
	V6Only       string
	AsnID        sql.NullInt64
	CountryID    sql.NullInt64
	Disabled     bool
	TsBaseDomain sql.NullTime
	TsWwwDomain  sql.NullTime
	TsNameserver sql.NullTime
	TsMxRecord   sql.NullTime
	TsV6Only     sql.NullTime
	TsCheck      sql.NullTime
	TsUpdated    sql.NullTime
	Asname       sql.NullString
	CountryName  sql.NullString
}

// Description: Retrieves a list of campaign domains with additional information from 'asn' and 'country' tables.
func (q *Queries) ListCampaignDomain(ctx context.Context, arg ListCampaignDomainParams) ([]ListCampaignDomainRow, error) {
	rows, err := q.db.Query(ctx, ListCampaignDomain, arg.CampaignID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCampaignDomainRow{}
	for rows.Next() {
		var i ListCampaignDomainRow
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Site,
			&i.BaseDomain,
			&i.WwwDomain,
			&i.Nameserver,
			&i.MxRecord,
			&i.V6Only,
			&i.AsnID,
			&i.CountryID,
			&i.Disabled,
			&i.TsBaseDomain,
			&i.TsWwwDomain,
			&i.TsNameserver,
			&i.TsMxRecord,
			&i.TsV6Only,
			&i.TsCheck,
			&i.TsUpdated,
			&i.Asname,
			&i.CountryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateCampaignDomain = `-- name: UpdateCampaignDomain :exec
UPDATE
    campaign_domain
SET base_domain    = $3,
    www_domain     = $4,
    nameserver     = $5,
    mx_record      = $6,
    v6_only        = $7,
    ts_base_domain = $8,
    ts_www_domain  = $9,
    ts_nameserver  = $10,
    ts_mx_record   = $11,
    ts_v6_only     = $12,
    ts_check       = $13,
    ts_updated     = $14,
    asn_id         = $15,
    country_id     = $16
WHERE site = $1
  AND campaign_id = $2
`

type UpdateCampaignDomainParams struct {
	Site         string
	CampaignID   uuid.UUID
	BaseDomain   string
	WwwDomain    string
	Nameserver   string
	MxRecord     string
	V6Only       string
	TsBaseDomain sql.NullTime
	TsWwwDomain  sql.NullTime
	TsNameserver sql.NullTime
	TsMxRecord   sql.NullTime
	TsV6Only     sql.NullTime
	TsCheck      sql.NullTime
	TsUpdated    sql.NullTime
	AsnID        sql.NullInt64
	CountryID    sql.NullInt64
}

func (q *Queries) UpdateCampaignDomain(ctx context.Context, arg UpdateCampaignDomainParams) error {
	_, err := q.db.Exec(ctx, UpdateCampaignDomain,
		arg.Site,
		arg.CampaignID,
		arg.BaseDomain,
		arg.WwwDomain,
		arg.Nameserver,
		arg.MxRecord,
		arg.V6Only,
		arg.TsBaseDomain,
		arg.TsWwwDomain,
		arg.TsNameserver,
		arg.TsMxRecord,
		arg.TsV6Only,
		arg.TsCheck,
		arg.TsUpdated,
		arg.AsnID,
		arg.CountryID,
	)
	return err
}

const ViewCampaignDomain = `-- name: ViewCampaignDomain :one
SELECT campaign_domain.id, campaign_domain.campaign_id, campaign_domain.site, campaign_domain.base_domain, campaign_domain.www_domain, campaign_domain.nameserver, campaign_domain.mx_record, campaign_domain.v6_only, campaign_domain.asn_id, campaign_domain.country_id, campaign_domain.disabled, campaign_domain.ts_base_domain, campaign_domain.ts_www_domain, campaign_domain.ts_nameserver, campaign_domain.ts_mx_record, campaign_domain.ts_v6_only, campaign_domain.ts_check, campaign_domain.ts_updated,
       asn.name as asname,
       country.country_name
FROM campaign_domain
         LEFT JOIN asn ON campaign_domain.asn_id = asn.id
         LEFT JOIN country ON campaign_domain.country_id = country.id
WHERE site = $1
  AND campaign_id = $2
LIMIT 1
`

type ViewCampaignDomainParams struct {
	Site       string
	CampaignID uuid.UUID
}

type ViewCampaignDomainRow struct {
	ID           int64
	CampaignID   uuid.UUID
	Site         string
	BaseDomain   string
	WwwDomain    string
	Nameserver   string
	MxRecord     string
	V6Only       string
	AsnID        sql.NullInt64
	CountryID    sql.NullInt64
	Disabled     bool
	TsBaseDomain sql.NullTime
	TsWwwDomain  sql.NullTime
	TsNameserver sql.NullTime
	TsMxRecord   sql.NullTime
	TsV6Only     sql.NullTime
	TsCheck      sql.NullTime
	TsUpdated    sql.NullTime
	Asname       sql.NullString
	CountryName  sql.NullString
}

func (q *Queries) ViewCampaignDomain(ctx context.Context, arg ViewCampaignDomainParams) (ViewCampaignDomainRow, error) {
	row := q.db.QueryRow(ctx, ViewCampaignDomain, arg.Site, arg.CampaignID)
	var i ViewCampaignDomainRow
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Site,
		&i.BaseDomain,
		&i.WwwDomain,
		&i.Nameserver,
		&i.MxRecord,
		&i.V6Only,
		&i.AsnID,
		&i.CountryID,
		&i.Disabled,
		&i.TsBaseDomain,
		&i.TsWwwDomain,
		&i.TsNameserver,
		&i.TsMxRecord,
		&i.TsV6Only,
		&i.TsCheck,
		&i.TsUpdated,
		&i.Asname,
		&i.CountryName,
	)
	return i, err
}
