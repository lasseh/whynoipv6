// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: campaign.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const CrawlCampaignDomain = `-- name: CrawlCampaignDomain :many
SELECT id, campaign_id, site, check_aaaa, check_www, check_ns, check_curl, asn_id, country_id, disabled, ts_aaaa, ts_www, ts_ns, ts_curl, ts_check, ts_updated
FROM campaign_domain
ORDER BY id
LIMIT $1 OFFSET $2
`

type CrawlCampaignDomainParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) CrawlCampaignDomain(ctx context.Context, arg CrawlCampaignDomainParams) ([]CampaignDomain, error) {
	rows, err := q.db.Query(ctx, CrawlCampaignDomain, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CampaignDomain{}
	for rows.Next() {
		var i CampaignDomain
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Site,
			&i.CheckAaaa,
			&i.CheckWww,
			&i.CheckNs,
			&i.CheckCurl,
			&i.AsnID,
			&i.CountryID,
			&i.Disabled,
			&i.TsAaaa,
			&i.TsWww,
			&i.TsNs,
			&i.TsCurl,
			&i.TsCheck,
			&i.TsUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const CreateCampaign = `-- name: CreateCampaign :one
INSERT INTO campaign(name, description)
VALUES ($1, $2)
RETURNING id, created_at, uuid, name, description, disabled
`

type CreateCampaignParams struct {
	Name        string
	Description string
}

func (q *Queries) CreateCampaign(ctx context.Context, arg CreateCampaignParams) (Campaign, error) {
	row := q.db.QueryRow(ctx, CreateCampaign, arg.Name, arg.Description)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.Disabled,
	)
	return i, err
}

const CreateOrUpdateCampaign = `-- name: CreateOrUpdateCampaign :one
INSERT INTO campaign(uuid, name, description)
VALUES ($1, $2, $3)
ON CONFLICT (uuid) DO UPDATE
    SET name        = EXCLUDED.name,
        description = EXCLUDED.description
RETURNING id, created_at, uuid, name, description, disabled
`

type CreateOrUpdateCampaignParams struct {
	Uuid        uuid.UUID
	Name        string
	Description string
}

func (q *Queries) CreateOrUpdateCampaign(ctx context.Context, arg CreateOrUpdateCampaignParams) (Campaign, error) {
	row := q.db.QueryRow(ctx, CreateOrUpdateCampaign, arg.Uuid, arg.Name, arg.Description)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.Disabled,
	)
	return i, err
}

const DeleteCampaignDomain = `-- name: DeleteCampaignDomain :exec
DELETE
FROM campaign_domain
WHERE campaign_id = $1
  AND site = $2
`

type DeleteCampaignDomainParams struct {
	CampaignID uuid.UUID
	Site       string
}

func (q *Queries) DeleteCampaignDomain(ctx context.Context, arg DeleteCampaignDomainParams) error {
	_, err := q.db.Exec(ctx, DeleteCampaignDomain, arg.CampaignID, arg.Site)
	return err
}

const DisableCampaignDomain = `-- name: DisableCampaignDomain :exec
UPDATE
    campaign_domain
SET disabled = TRUE
WHERE site = $1
`

func (q *Queries) DisableCampaignDomain(ctx context.Context, site string) error {
	_, err := q.db.Exec(ctx, DisableCampaignDomain, site)
	return err
}

const GetCampaignByUUID = `-- name: GetCampaignByUUID :one
SELECT campaign.id, campaign.created_at, campaign.uuid, campaign.name, campaign.description, campaign.disabled,
       COUNT(campaign_domain.id) AS domain_count,
       COUNT(
           CASE
           WHEN campaign_domain.check_aaaa = true AND
                campaign_domain.check_www = true AND
                campaign_domain.check_ns = true
           THEN TRUE
           ELSE NULL
           END
       ) AS v6_ready_count
FROM campaign
         LEFT JOIN campaign_domain ON campaign.uuid = campaign_domain.campaign_id
WHERE campaign.uuid = $1
GROUP BY campaign.id
LIMIT 1
`

type GetCampaignByUUIDRow struct {
	ID           int64
	CreatedAt    time.Time
	Uuid         uuid.UUID
	Name         string
	Description  string
	Disabled     bool
	DomainCount  int64
	V6ReadyCount int64
}

func (q *Queries) GetCampaignByUUID(ctx context.Context, argUuid uuid.UUID) (GetCampaignByUUIDRow, error) {
	row := q.db.QueryRow(ctx, GetCampaignByUUID, argUuid)
	var i GetCampaignByUUIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.Disabled,
		&i.DomainCount,
		&i.V6ReadyCount,
	)
	return i, err
}

const GetCampaignDomainsByName = `-- name: GetCampaignDomainsByName :many
SELECT id, campaign_id, site, check_aaaa, check_www, check_ns, check_curl, asn_id, country_id, disabled, ts_aaaa, ts_www, ts_ns, ts_curl, ts_check, ts_updated
FROM campaign_domain
WHERE site LIKE '%' || $1 || '%'
LIMIT $2 OFFSET $3
`

type GetCampaignDomainsByNameParams struct {
	Column1 sql.NullString
	Limit   int32
	Offset  int32
}

// Used for searching campaign domains by site name.
func (q *Queries) GetCampaignDomainsByName(ctx context.Context, arg GetCampaignDomainsByNameParams) ([]CampaignDomain, error) {
	rows, err := q.db.Query(ctx, GetCampaignDomainsByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CampaignDomain{}
	for rows.Next() {
		var i CampaignDomain
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Site,
			&i.CheckAaaa,
			&i.CheckWww,
			&i.CheckNs,
			&i.CheckCurl,
			&i.AsnID,
			&i.CountryID,
			&i.Disabled,
			&i.TsAaaa,
			&i.TsWww,
			&i.TsNs,
			&i.TsCurl,
			&i.TsCheck,
			&i.TsUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const InsertCampaignDomain = `-- name: InsertCampaignDomain :exec
INSERT INTO campaign_domain(campaign_id, site)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type InsertCampaignDomainParams struct {
	CampaignID uuid.UUID
	Site       string
}

// The ON CONFLICT DO NOTHING clause prevents errors in case a record with the same campaign_id and site already exists.
func (q *Queries) InsertCampaignDomain(ctx context.Context, arg InsertCampaignDomainParams) error {
	_, err := q.db.Exec(ctx, InsertCampaignDomain, arg.CampaignID, arg.Site)
	return err
}

const ListCampaign = `-- name: ListCampaign :many
SELECT campaign.id, campaign.created_at, campaign.uuid, campaign.name, campaign.description, campaign.disabled,
       COUNT(campaign_domain.id) AS domain_count,
       COUNT(
           CASE
           WHEN campaign_domain.check_aaaa = true AND
                campaign_domain.check_www = true AND
                campaign_domain.check_ns = true
           THEN TRUE
           ELSE NULL
           END
       ) AS v6_ready_count
FROM campaign
LEFT JOIN campaign_domain ON campaign.uuid = campaign_domain.campaign_id AND campaign.disabled = false
GROUP BY campaign.id
ORDER BY campaign.id
`

type ListCampaignRow struct {
	ID           int64
	CreatedAt    time.Time
	Uuid         uuid.UUID
	Name         string
	Description  string
	Disabled     bool
	DomainCount  int64
	V6ReadyCount int64
}

// Description: Retrieves a list of campaigns along with their associated domain count.
func (q *Queries) ListCampaign(ctx context.Context) ([]ListCampaignRow, error) {
	rows, err := q.db.Query(ctx, ListCampaign)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCampaignRow{}
	for rows.Next() {
		var i ListCampaignRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.Disabled,
			&i.DomainCount,
			&i.V6ReadyCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListCampaignDomain = `-- name: ListCampaignDomain :many
SELECT campaign_domain.id, campaign_domain.campaign_id, campaign_domain.site, campaign_domain.check_aaaa, campaign_domain.check_www, campaign_domain.check_ns, campaign_domain.check_curl, campaign_domain.asn_id, campaign_domain.country_id, campaign_domain.disabled, campaign_domain.ts_aaaa, campaign_domain.ts_www, campaign_domain.ts_ns, campaign_domain.ts_curl, campaign_domain.ts_check, campaign_domain.ts_updated,
       asn.name as asname,
       country.country_name
FROM campaign_domain
         LEFT JOIN asn ON campaign_domain.asn_id = asn.id
         LEFT JOIN country ON campaign_domain.country_id = country.id
WHERE campaign_domain.campaign_id = $1
ORDER BY campaign_domain.id
LIMIT $2 OFFSET $3
`

type ListCampaignDomainParams struct {
	CampaignID uuid.UUID
	Limit      int32
	Offset     int32
}

type ListCampaignDomainRow struct {
	ID          int64
	CampaignID  uuid.UUID
	Site        string
	CheckAaaa   bool
	CheckWww    bool
	CheckNs     bool
	CheckCurl   bool
	AsnID       sql.NullInt64
	CountryID   sql.NullInt64
	Disabled    bool
	TsAaaa      sql.NullTime
	TsWww       sql.NullTime
	TsNs        sql.NullTime
	TsCurl      sql.NullTime
	TsCheck     sql.NullTime
	TsUpdated   sql.NullTime
	Asname      sql.NullString
	CountryName sql.NullString
}

// Description: Retrieves a list of campaign domains with additional information from 'asn' and 'country' tables.
func (q *Queries) ListCampaignDomain(ctx context.Context, arg ListCampaignDomainParams) ([]ListCampaignDomainRow, error) {
	rows, err := q.db.Query(ctx, ListCampaignDomain, arg.CampaignID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCampaignDomainRow{}
	for rows.Next() {
		var i ListCampaignDomainRow
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Site,
			&i.CheckAaaa,
			&i.CheckWww,
			&i.CheckNs,
			&i.CheckCurl,
			&i.AsnID,
			&i.CountryID,
			&i.Disabled,
			&i.TsAaaa,
			&i.TsWww,
			&i.TsNs,
			&i.TsCurl,
			&i.TsCheck,
			&i.TsUpdated,
			&i.Asname,
			&i.CountryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateCampaignDomain = `-- name: UpdateCampaignDomain :exec
UPDATE
    campaign_domain
SET check_aaaa = $3,
    check_www  = $4,
    check_ns   = $5,
    check_curl = $6,
    ts_aaaa    = $7,
    ts_www     = $8,
    ts_ns      = $9,
    ts_curl    = $10,
    ts_check   = $11,
    ts_updated = $12,
    asn_id     = $13,
    country_id = $14
WHERE site = $1
  AND campaign_id = $2
`

type UpdateCampaignDomainParams struct {
	Site       string
	CampaignID uuid.UUID
	CheckAaaa  bool
	CheckWww   bool
	CheckNs    bool
	CheckCurl  bool
	TsAaaa     sql.NullTime
	TsWww      sql.NullTime
	TsNs       sql.NullTime
	TsCurl     sql.NullTime
	TsCheck    sql.NullTime
	TsUpdated  sql.NullTime
	AsnID      sql.NullInt64
	CountryID  sql.NullInt64
}

func (q *Queries) UpdateCampaignDomain(ctx context.Context, arg UpdateCampaignDomainParams) error {
	_, err := q.db.Exec(ctx, UpdateCampaignDomain,
		arg.Site,
		arg.CampaignID,
		arg.CheckAaaa,
		arg.CheckWww,
		arg.CheckNs,
		arg.CheckCurl,
		arg.TsAaaa,
		arg.TsWww,
		arg.TsNs,
		arg.TsCurl,
		arg.TsCheck,
		arg.TsUpdated,
		arg.AsnID,
		arg.CountryID,
	)
	return err
}

const ViewCampaignDomain = `-- name: ViewCampaignDomain :one
SELECT campaign_domain.id, campaign_domain.campaign_id, campaign_domain.site, campaign_domain.check_aaaa, campaign_domain.check_www, campaign_domain.check_ns, campaign_domain.check_curl, campaign_domain.asn_id, campaign_domain.country_id, campaign_domain.disabled, campaign_domain.ts_aaaa, campaign_domain.ts_www, campaign_domain.ts_ns, campaign_domain.ts_curl, campaign_domain.ts_check, campaign_domain.ts_updated,
       asn.name as asname,
       country.country_name
FROM campaign_domain
         LEFT JOIN asn ON campaign_domain.asn_id = asn.id
         LEFT JOIN country ON campaign_domain.country_id = country.id
WHERE site = $1
  AND campaign_id = $2
LIMIT 1
`

type ViewCampaignDomainParams struct {
	Site       string
	CampaignID uuid.UUID
}

type ViewCampaignDomainRow struct {
	ID          int64
	CampaignID  uuid.UUID
	Site        string
	CheckAaaa   bool
	CheckWww    bool
	CheckNs     bool
	CheckCurl   bool
	AsnID       sql.NullInt64
	CountryID   sql.NullInt64
	Disabled    bool
	TsAaaa      sql.NullTime
	TsWww       sql.NullTime
	TsNs        sql.NullTime
	TsCurl      sql.NullTime
	TsCheck     sql.NullTime
	TsUpdated   sql.NullTime
	Asname      sql.NullString
	CountryName sql.NullString
}

func (q *Queries) ViewCampaignDomain(ctx context.Context, arg ViewCampaignDomainParams) (ViewCampaignDomainRow, error) {
	row := q.db.QueryRow(ctx, ViewCampaignDomain, arg.Site, arg.CampaignID)
	var i ViewCampaignDomainRow
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Site,
		&i.CheckAaaa,
		&i.CheckWww,
		&i.CheckNs,
		&i.CheckCurl,
		&i.AsnID,
		&i.CountryID,
		&i.Disabled,
		&i.TsAaaa,
		&i.TsWww,
		&i.TsNs,
		&i.TsCurl,
		&i.TsCheck,
		&i.TsUpdated,
		&i.Asname,
		&i.CountryName,
	)
	return i, err
}
