// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: country.sql

package db

import (
	"context"
	"database/sql"
)

const AllDomainsByCountry = `-- name: AllDomainsByCountry :many
SELECT id, site, base_domain, www_domain, nameserver, mx_record, v6_only, asn_id, country_id, disabled, ts_base_domain, ts_www_domain, ts_nameserver, ts_mx_record, ts_v6_only, ts_check, ts_updated, rank, asname, country_name
FROM domain_view_list
WHERE domain_view_list.country_id = $1
ORDER BY domain_view_list.id
LIMIT $2 OFFSET $3
`

type AllDomainsByCountryParams struct {
	CountryID sql.NullInt64
	Limit     int64
	Offset    int64
}

func (q *Queries) AllDomainsByCountry(ctx context.Context, arg AllDomainsByCountryParams) ([]DomainViewList, error) {
	rows, err := q.db.Query(ctx, AllDomainsByCountry, arg.CountryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DomainViewList{}
	for rows.Next() {
		var i DomainViewList
		if err := rows.Scan(
			&i.ID,
			&i.Site,
			&i.BaseDomain,
			&i.WwwDomain,
			&i.Nameserver,
			&i.MxRecord,
			&i.V6Only,
			&i.AsnID,
			&i.CountryID,
			&i.Disabled,
			&i.TsBaseDomain,
			&i.TsWwwDomain,
			&i.TsNameserver,
			&i.TsMxRecord,
			&i.TsV6Only,
			&i.TsCheck,
			&i.TsUpdated,
			&i.Rank,
			&i.Asname,
			&i.CountryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCountry = `-- name: GetCountry :one
SELECT id, country_name, country_code, country_tld, continent, sites, v6sites, percent
FROM country
WHERE country_code = $1
LIMIT 1
`

func (q *Queries) GetCountry(ctx context.Context, countryCode string) (Country, error) {
	row := q.db.QueryRow(ctx, GetCountry, countryCode)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.CountryName,
		&i.CountryCode,
		&i.CountryTld,
		&i.Continent,
		&i.Sites,
		&i.V6sites,
		&i.Percent,
	)
	return i, err
}

const GetCountryTld = `-- name: GetCountryTld :one
SELECT id, country_name, country_code, country_tld, continent, sites, v6sites, percent
FROM country
WHERE country_tld = $1
LIMIT 1
`

func (q *Queries) GetCountryTld(ctx context.Context, countryTld string) (Country, error) {
	row := q.db.QueryRow(ctx, GetCountryTld, countryTld)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.CountryName,
		&i.CountryCode,
		&i.CountryTld,
		&i.Continent,
		&i.Sites,
		&i.V6sites,
		&i.Percent,
	)
	return i, err
}

const ListCountry = `-- name: ListCountry :many
SELECT id, country_name, country_code, country_tld, continent, sites, v6sites, percent
FROM country
ORDER BY sites DESC
`

func (q *Queries) ListCountry(ctx context.Context) ([]Country, error) {
	rows, err := q.db.Query(ctx, ListCountry)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Country{}
	for rows.Next() {
		var i Country
		if err := rows.Scan(
			&i.ID,
			&i.CountryName,
			&i.CountryCode,
			&i.CountryTld,
			&i.Continent,
			&i.Sites,
			&i.V6sites,
			&i.Percent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListDomainHeroesByCountry = `-- name: ListDomainHeroesByCountry :many
SELECT id, site, base_domain, www_domain, nameserver, mx_record, v6_only, asn_id, country_id, disabled, ts_base_domain, ts_www_domain, ts_nameserver, ts_mx_record, ts_v6_only, ts_check, ts_updated, rank, asname, country_name
FROM domain_view_list
WHERE country_id = $1
  AND base_domain = 'supported'
  AND www_domain = 'supported'
  AND nameserver = 'supported'
  AND mx_record != 'unsupported'
ORDER BY rank
LIMIT $2 OFFSET $3
`

type ListDomainHeroesByCountryParams struct {
	CountryID sql.NullInt64
	Limit     int64
	Offset    int64
}

func (q *Queries) ListDomainHeroesByCountry(ctx context.Context, arg ListDomainHeroesByCountryParams) ([]DomainViewList, error) {
	rows, err := q.db.Query(ctx, ListDomainHeroesByCountry, arg.CountryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DomainViewList{}
	for rows.Next() {
		var i DomainViewList
		if err := rows.Scan(
			&i.ID,
			&i.Site,
			&i.BaseDomain,
			&i.WwwDomain,
			&i.Nameserver,
			&i.MxRecord,
			&i.V6Only,
			&i.AsnID,
			&i.CountryID,
			&i.Disabled,
			&i.TsBaseDomain,
			&i.TsWwwDomain,
			&i.TsNameserver,
			&i.TsMxRecord,
			&i.TsV6Only,
			&i.TsCheck,
			&i.TsUpdated,
			&i.Rank,
			&i.Asname,
			&i.CountryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListDomainsByCountry = `-- name: ListDomainsByCountry :many
SELECT id, site, base_domain, www_domain, nameserver, mx_record, v6_only, asn_id, country_id, disabled, ts_base_domain, ts_www_domain, ts_nameserver, ts_mx_record, ts_v6_only, ts_check, ts_updated, rank, asname, country_name
FROM domain_view_list
WHERE domain_view_list.country_id = $1
  AND (
      domain_view_list.base_domain = 'unsupported'
      OR domain_view_list.www_domain = 'unsupported'
    )
ORDER BY domain_view_list.id
LIMIT $2 OFFSET $3
`

type ListDomainsByCountryParams struct {
	CountryID sql.NullInt64
	Limit     int64
	Offset    int64
}

func (q *Queries) ListDomainsByCountry(ctx context.Context, arg ListDomainsByCountryParams) ([]DomainViewList, error) {
	rows, err := q.db.Query(ctx, ListDomainsByCountry, arg.CountryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DomainViewList{}
	for rows.Next() {
		var i DomainViewList
		if err := rows.Scan(
			&i.ID,
			&i.Site,
			&i.BaseDomain,
			&i.WwwDomain,
			&i.Nameserver,
			&i.MxRecord,
			&i.V6Only,
			&i.AsnID,
			&i.CountryID,
			&i.Disabled,
			&i.TsBaseDomain,
			&i.TsWwwDomain,
			&i.TsNameserver,
			&i.TsMxRecord,
			&i.TsV6Only,
			&i.TsCheck,
			&i.TsUpdated,
			&i.Rank,
			&i.Asname,
			&i.CountryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
